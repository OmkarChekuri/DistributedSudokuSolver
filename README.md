
THE LINK TO PRESENTATION IS AVAILABLE AT "https://youtu.be/nXYhXXls7fg"

HOW TO START THE PROGRAM:
TO START THE FRESH BUILD OF THE DOCKER RUN THE FOLLOWING COMMAND WITH ALL THE REQUIRED FILES.
DOCKER-COMPOSE UP --BUILD

THE DOCKER BUILDS THE REQUIRED CONTAINER AND CREATES THE CLIENTS AND SERVERS. 
IT NOW EXECUTES THE NODE.PY FILE.

NODE.PY IS THE MAIN FILE IT DOES THE FOLLOWING TASKS. 
1. IT CREATES CLIENTS AND SERVERS. 

2. BOTH CLIENT AND SERVER HAVE ALREADY HAD A PUBLIC KEY WITH THEM. THIS KEY CONSISTS OF ANY TWO INTEGERS.

3. WHEN THE CLIENT WANTS TO ESTABLISH A CONNECTION WITH SERVER THE CLIENT REQUESTS THE PUBLIC KEY OF THE SERVER. 

4. THE SERVER SENDS ITS PUBLIC KEY TO THE CLIENT. THE CLIENT USES THE PUBLIC KEY TO ENCRIPT THE MESSAGE WITH ITS CUSTOM 
   ENCRIPT FUNCTION.

5. THE ENCRYPT FUNCTION TAKES THE PARAMETERS ORIGINAL MESSAGE, THE PUBLIC KEY (N,E) OF THE DESTINATION. 
IT TAKES THE MESSAGE AND CONVERTS EACH CHARACTER INTO ASCII CODE. 
IT THEN ADDS N^E FROM THE PUBLIC KEY (N,E) RECEIVED FROM SERVER TO THE ASCII CODE OF EACH CHARACTER.
IT THEN ADDS RANDOM CHARACTERS TO THE RESULTING NUMBER AND DOES THIS FOR ALL THE CHARACTERS WHILE
CONCATENATING THE RESULT TO FORM THE ENCRYPTED MESSAGE.

6. IT NOW SENDS  THE ENCRYPTED MESSAGE AND TWO STRINGS ,ITS HOST NAME AND THE HOST NAME OF THE SERVER TO THE SERVER.

6. THE SERVER RECIEVES THE ENCRYPTED MESSAGE FROM THE CLIENT AND DECRYPTS THE MESSAGE WITH THE DECRYPTION FUNCTION. HERE THE 
DECRYPTED MESSAGE IS NAME OF THE CLIENT.


7. THE DECRYPT FUNCTION TAKES THE PARAMETERS THE ENCRYPTED MESSAGE, PUBLIC KEY (N,E) TO DECRYPT THE MESSAGE.
IT STARTS OF BY REMOVING THE RANDOM CHARACTERS FROM THE ENCRYPTED MESSAGE THAT SEPARATES THE NUMBERS OBTAINED FROM
ADDING N^E TO THE ASCII CODE. IT THEN SUBTRACTS N^E FROM EACH OF THE NUMBERS TO GET THE ASCII CODES
IT THEN CONVERTS THE ASCII CODES TO GET THE CHARACTERS AND THEN COMBINES THEM TO GET THE ORIGINAL MESSAGE.

8. THE SERVER STORES THE SUDOKU.THE ENCRIPTED MESSAGE FROM THE SERVER CONSISTS OF THE CLIENT NAME.
ONCE THE SERVER VERIFIES THE CLIENT NAME. IT SENDS THE REQUIRED CELLS OR LATIN SQUARE CORRESPONDING TO THE CLIENT THAT REQUESTED.

9. THE CLIENTS REQUESTS THE SERVER IF ITS NEIGHBOURS ARE ACTIVE, THE SERVER MAINTAINS A ACTIVELIST OF ALL THE CLIENTS THAT CONTACTED IT
IF IT NEIGHBOURS OF THE REQUESTED CLIENT ARE IN THE ACTIVELIST, THE SERVER SENDS THE ACTIVELIST TO THE CLIENT, ELSE IT SENDS AN EMPTY LIST.

10. IF THE CLIENT RECIEVES AN EMPTY LIST FROM THE SERVER, IT WAITS FOR A WHILE AND REQUESTS AGAIN UNTIL IT RECIEVES THE NEIGHBOURS LIST.

11. IF THE CLIENT RECIEVES THE NEIGHBORS LIST, IT PROCEEDS TO NEXT STEP

9. EACH CLIENT STORES THE NAMES OF ITS NEIGHBOURS.THEY ALSO DEFINE THEIR OWN STUBS SIMILAR TO THE SERVER TO ACT AS SERVERS.

10. THE SERVER IMPLEMENTS A ROUND ROBIN SCHEDULING ALGORITHM.  IN THE SERVER THEIR IS A DICTIONARY THAT CORRESPONDS TO ENTRIES OF TOKEN
 ASSIGNED TO THE CLIENTS THAT DETERMINES WHETHER CLIENTS CAN TALK TO THEIR NEIGHBOURS. INITIALLY ALL THE TOKENS ARE ZERO. WHENEVER THE CLIENT WANTS TO COMMUNICATE WITH ITS NEIGHBOURS, IT CHECKS THE AVAILABILITY OF THE TOKEN WITH THE SERVER. IF THE TOKEN IS NOT ALREADY ASSIGNED TO OTHER CLIENTS, THE SERVER ALLOTS A TOKEN OF SIX TIME SLOTS.

11. THE CLIENT COMMUNICATES WITH ALL OF ITS NEIGHBOURS IF THE TOKEN IS VALID AND ITS NEIGHBOURS ARE ACTIVE. THE TOKEN IS NOW DECREMENTED BY ONE. THE CLIENT CONTINUES COMMUNICATING WITH ITS NEIGHBOURS UNTIL ITS TOKEN BECOMES ZERO.

12. THE CLIENT TO CLIENT COMMUNICATION IS AS FOLLOWS:
ONCE THE CLIENT VERIFIES THAT ITS TOKEN IS GREATER THAN ZERO, IT THEN REQUESTS NEIGHBOURS THEIR LATIN SQUARE AND GETS IT. IT STORES IT IN ITS DATA STRUCTURE. BY DOING THIS EVERY CLIENT MAINTAINS A REDUNDANT COPY OF ITS DATA WITH ITS NEIGHBOURS. THIS CONTINUES AS LONG AS THE CLIENT AND SERVER ARE ALIVE. WE CAN USE OTHER MICRO SERVICES TO CHANGE THE DATA IN ANY OF THE CLIENTS. 
IF WE DO THAT THE DATA IS AUTOMATICALLY UPDATED IN ITS NEIGHBOURS AND THE REDUNDANT COPIES OF THE DATA ARE MAINTAINED.


13. IF THE TOKEN OF THE CURRENTLY ACTIVE CLIENT BECOMES ZERO, THE SERVER ASSIGNS THE TOKEN  TO NEXT IN LINE CLIENT AND PROCEEDS STEP 11 WITH THIS NEW CLIENT. 

 
12. THE PROTO FILE CONSISTS OF THE FOLLOWING METHOD SIGNATURES FOR THE BELOW MENTIONED PURPOSES.

    A)GETPUBLICKEY: THIS METHOD IS USED TO COMMUNICATE THE SECURITY KEY BETWEEN THE CLIENT AND THE SERVER. THE CLIENT REQUESTS THE PUBLIC KEY OF THE SERVER USING THIS METHOD.

    B)SENDENCRYPTEDMESSAGE: THIS METHOD IS USED TO SEND THE IDENTITY OF THE CLIENT TO THE SERVER IN AN ENCRYPTED MESSAGE.

    C)GETSUBMATRIX: THIS METHOD IS USED BY THE CLIENT TO GET ITS INITIAL LATIN SQUARE FROM THE SERVER AS WELL AS STORING THE LITIN SQUARES OF THE NEIGHBOURS WITH IT.

    D)GETROUNDROBINTOKEN:  THIS METHOD IS USED BY THE CLIENT TO GET THE ROUND ROBIN KEY FROM THE SERVER AND RUN ONLY IF THE KEY OR THE TOKEN IS VALID.

    E)isMyNeighboursActive : THIS METHOD IS USED BY THE CLIENT TO CHECK WITH THE SERVER, IF ITS NEIGHBOURS ARE ACTIVE, THE CLIENT WILL TRY TO MAKE CONNECTIONS TO ITS NEIGHBOURS ONLY IF IT RECIEVES RESPONSE FROM THE SERVER THAT ITS CLIENTS ARE ACTIVE.

  

